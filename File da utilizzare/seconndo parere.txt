Ciao! Ho analizzato attentamente i file che hai caricato, in particolare src/app/dashboard/page.tsx e la configurazione di Supabase.

Il "nuovo problema" che riscontri (disconnessione dopo inutilizzo, risolvibile solo con F5) e il fatto che il caricamento a volte si blocchi, derivano da un conflitto fondamentale nel codice attuale:

Il file src/app/dashboard/page.tsx √® ancora un Client Component ("use client"), ma la gestione della sessione di Supabase √® configurata per funzionare lato Server (tramite Middleware).

‚ö†Ô∏è Perch√© succede? (Diagnosi Tecnica)
Sessione Scaduta: Il token di accesso di Supabase dura circa 1 ora. In una configurazione moderna Next.js + Supabase SSR, √® il Middleware (middleware.ts) che si occupa di rinnovare questo token.

Il blocco: Il Middleware si attiva solo quando fai una richiesta al server (es. ricarichi la pagina o navighi). Se rimani fermo sulla Dashboard (che √® renderizzata lato Client) o cambi scheda nel browser, il Middleware non viene mai chiamato.

Risultato: Il token scade mentre la pagina √® aperta. Quando torni sulla scheda e l'app prova a chiamare il database, il token √® vecchio e la richiesta fallisce. Premendo F5, forzi il browser a chiamare il server -> il Middleware parte -> il token si rinnova -> tutto funziona.

üõ†Ô∏è La Soluzione Definitiva: Server Components
Per risolvere definitivamente e rendere l'app veloce e stabile, dobbiamo spostare il recupero dati sul Server. In questo modo, ogni volta che la pagina viene caricata o ricaricata, il server gestisce la connessione (che √® molto pi√π stabile del browser).

Segui questi 2 passaggi precisi per sostituire il codice attuale.

Passo 1: Crea il componente per la vista (DashboardClient.tsx)
Crea un nuovo file in src/components/dashboard/DashboardClient.tsx. Questo file si occuper√† solo di mostrare i dati che il server gli passer√†.

TypeScript

"use client";

import { useState } from "react";
import DashboardLayout from "@/components/layout/DashboardLayout";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { StatsCards } from "@/components/dashboard/StatsCards";
import { CalendarView } from "@/components/dashboard/CalendarView";
import { AttendanceChart } from "@/components/dashboard/AttendanceChart";
import { RecentMovements } from "@/components/dashboard/RecentMovements";
import { ActiveJobsWidget } from "@/components/dashboard/ActiveJobs";

// Interfaccia per i dati che arriveranno dal server
interface DashboardStats {
  totalValue: number;
  lowStockCount: number;
  totalItems: number;
}

export function DashboardClient({ initialStats }: { initialStats: DashboardStats }) {
  const [activeTab, setActiveTab] = useState("overview");

  return (
    <DashboardLayout>
      <div className="space-y-6">
        <div className="flex justify-between items-center mb-6">
           <h1 className="text-2xl font-bold text-slate-900 dark:text-white hidden md:block">Dashboard</h1>
        </div>

        <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-4">
          <TabsList>
            <TabsTrigger value="overview">Panoramica</TabsTrigger>
            <TabsTrigger value="calendar">Calendario Presenze</TabsTrigger>
            <TabsTrigger value="analytics">Analisi</TabsTrigger>
          </TabsList>

          <TabsContent value="overview" className="space-y-4">
            <StatsCards 
              totalValue={initialStats.totalValue} 
              lowStockCount={initialStats.lowStockCount}
              totalItems={initialStats.totalItems}
            />
            
            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-7">
                <div className="col-span-4">
                  <RecentMovements />
                </div>
                <div className="col-span-3">
                  <ActiveJobsWidget />
                </div>
            </div>
          </TabsContent>

          <TabsContent value="calendar" className="space-y-4">
            {activeTab === 'calendar' && <CalendarView />}
          </TabsContent>

          <TabsContent value="analytics" className="space-y-4">
            {activeTab === 'analytics' && <AttendanceChart />}
          </TabsContent>
        </Tabs>
      </div>
    </DashboardLayout>
  );
}
Passo 2: Sostituisci src/app/dashboard/page.tsx (Logica Server)
Copia e incolla questo codice interamente in src/app/dashboard/page.tsx. Nota che non c'√® pi√π "use client". Questo codice gira sul server, quindi non soffre dei problemi di "schede dormienti" del browser.

TypeScript

import { createClient } from "@/lib/supabase/server";
import { DashboardClient } from "@/components/dashboard/DashboardClient";
import { Suspense } from "react";
import { Skeleton } from "@/components/ui/skeleton";

// Scheletro di caricamento (Skeleton)
function DashboardSkeleton() {
  return (
    <div className="p-8 pt-6 space-y-6">
      <div className="flex justify-between items-center mb-6">
         <Skeleton className="h-8 w-48" />
      </div>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Skeleton className="h-32" />
        <Skeleton className="h-32" />
        <Skeleton className="h-32" />
      </div>
    </div>
  );
}

export default async function DashboardPage() {
  // 1. Inizializza il client Supabase lato server (usa i cookie sicuri)
  const supabase = await createClient();

  // 2. Esegui la query direttamente sul server
  // Questo √® molto pi√π veloce e sicuro rispetto al useEffect del client
  const { data: inventory, error } = await supabase
    .from('inventory')
    .select('quantity, price, min_stock');

  if (error) {
    console.error("Errore caricamento dashboard:", error);
  }

  // 3. Calcola le statistiche
  let totalValue = 0;
  let lowStockCount = 0;
  const totalItems = inventory?.length || 0;

  inventory?.forEach(item => {
    totalValue += (item.quantity || 0) * (item.price || 0);
    if ((item.quantity || 0) <= (item.min_stock || 0)) {
      lowStockCount++;
    }
  });

  const stats = {
    totalValue,
    lowStockCount,
    totalItems
  };

  // 4. Passa i dati pronti al componente Client
  return (
    <Suspense fallback={<DashboardSkeleton />}>
      <DashboardClient initialStats={stats} />
    </Suspense>
  );
}
Cosa cambia ora?
Con questa modifica:

Stabilit√†: Il caricamento avviene sui server (Vercel/Node), che sono sempre connessi. Non importa se l'utente ha lasciato la scheda aperta per 3 giorni; al refresh o alla navigazione, il server ricostruisce la pagina correttamente.

Velocit√†: Non devi aspettare il caricamento del JavaScript del browser per vedere i numeri. Arrivano gi√† pronti.

Token: Essendo una richiesta server, il Middleware intercetta automaticamente la chiamata e aggiorna il token se necessario, prevenendo le disconnessioni.